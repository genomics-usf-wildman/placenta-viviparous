#! /usr/bin/perl
# pubmed_grid grids pubmed search terms, and is released
# under the terms of the GPL version 2, or any later version, at your
# option. See the file README and COPYING for more information.
# Copyright 2008 by Don Armstrong <don@donarmstrong.com>.
# $Id: perl_script 1153 2008-04-08 00:04:20Z don $


use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;

=head1 NAME

pubmed_grid - does a grid search of pubmed search terms

=head1 SYNOPSIS

pubmed_grid [options]

 Options:
  --terms File which contains terms to run
  --dimension Terms to search at once (default 2)
  --unrun-field String to denote unrun comparison
  --pmid-output file to output set of pmids which match a given search term
  --pmid-input file previously generated by --pmid-output
  --debug, -d debugging level (default 0)
  --help, -h display this help
  --man, -m display manual

=head1 OPTIONS

=over

=item B<--terms>

File which contains terms to run. If specified once, the dimension is
used to figure out how many terms to run. If specified multiple times,
each term from each file is run against every other term.

Previously run terms are not run against eachother again

=item B<--dimension>

Terms to search at once (default 2)

In the case of more than two dimensions, the additional dimensions are folded in at the top

=item B<--unrun-field>

String used to denote fields that are unrun (generally because they
are duplicated elsewhere in the table)

Defaults to '', NA may also be sensible.

=item B<--pmid-output>

Output the set of pmids that matched a given search term

=item B<--pmid-input>

File generated by C<--pmid-output>; missing search terms will be run again

=item B<--debug, -d>

Debug verbosity. (Default 0)

=item B<--help, -h>

Display brief useage information.

=item B<--man, -m>

Display this manual.

=back

=head1 EXAMPLES


=cut

use List::Util qw(reduce);
use WWW::Mechanize;
use URI::Escape;

use List::MoreUtils qw(all uniq);

use Storable qw(dclone);

use vars qw($DEBUG);

my %options = (debug           => 0,
	       help            => 0,
	       man             => 0,
	       terms           => [],
	       output_pmids    => 0,
	       run_diagonal    => 1,
	       unrun_field     => '',
	       );

GetOptions(\%options,
	   'dimension=i',
	   'terms=s@',
	   'pmid_output|pmid-output=s',
	   'pmid_input|pmid-input=s',
	   'unrun_field|unrun-field=s',
	   'run_diagonal|run-diagonal!',
	   'output_pmids|output-pmids',
	   'debug|d+','help|h|?','man|m');

pod2usage() if $options{help};
pod2usage({verbose=>2}) if $options{man};

$DEBUG = $options{debug};

my @USAGE_ERRORS;

if (@{$options{terms}} > 1 and defined $options{dimension} and $options{dimension} != 1) {
    push @USAGE_ERRORS, "More than one set of terms and a dimension which is not one is nonsensical";
}

if (@{$options{terms}} == 1 and not exists $options{dimension}) {
    $options{dimension} = 2;
}

if (exists $options{dimension} and $options{dimension} < 1) {
    push @USAGE_ERRORS,"A dimension of less than one is nonsensical";
}

pod2usage(join("\n",@USAGE_ERRORS)) if @USAGE_ERRORS;


my @terms;

for my $term_fn (@{$options{terms}}) {
    my $term_fh = IO::File->new($term_fn,'r') or
	die "Unable to open $term_fn for reading: $!";
    push @terms,[];
    while (<$term_fh>) {
	chomp;
	next unless length $_;
	push @{$terms[-1]}, [split /\t/,$_];
    }
}
if (defined $options{dimension} and $options{dimension} > 1) {
    for my $dim (2..$options{dimension}) {
	$terms[$dim-1] = dclone($terms[0]);
    }
}

my %term_interactions_run;

if ($options{pmid_input}) {
    my $pmid_input = IO::File->new($options{pmid_input},'r') or
	die "Unable to open $options{pmid_input} for reading: $!";
    my $term_a;
    my $term_b;
    while (<$pmid_input>) {
	chomp;
	next if /^\s*#/;
	next if /^--/;
	if (m/(.+) and (.+)/) {
	    $term_a = $1;
	    $term_b = $2;
	}
	elsif (/^(\d+)$/ and defined $term_a and defined $term_b) {
	    $term_interactions_run{$term_a}{$term_b}{$1} = 1;
	    $term_interactions_run{$term_b}{$term_a}{$1} = 1;
	}
    }
    for $term_a (keys %term_interactions_run) {
	for $term_b (keys %{$term_interactions_run{$term_a}}) {
	    $term_interactions_run{$term_a}{$term_b} =
		[keys %{$term_interactions_run{$term_a}{$term_b}}];
	}
    }
}


my $pmid_output = undef;

if ($options{pmid_output}) {
    $pmid_output = IO::File->new($options{pmid_output},'w') or
	die "Unable to open $options{pmid_output} for writing: $!";
}


my $mech = WWW::Mechanize->new(autocheck => 0);

#if (not $options{output_pmids}) {
#    print join("\t",map {$_->[0]} @terms);
#    print "\n";
#}

my $n_terms = @terms;
if (@terms > 2) {
    die "more than two sets of terms not currently supported";
}

if (@terms == 2) {
    print join("\t",map {$_->[0]} @{$terms[1]}).qq(\n);
}

if (@terms == 1) {
    print join("\t","","count").qq(\n);
    $terms[1] = [['_alone_']];
}

for my $a (@{$terms[0]}) {
    print STDERR "working on $a->[0]\n";
    print $a->[0];
    for my $b (@{$terms[1]}) {
        print "\t";
        my @results;
        if (defined $term_interactions_run{$a->[0]}{$b->[0]}) {
            @results = @{$term_interactions_run{$a->[0]}{$b->[0]}}
        }
        elsif (defined $term_interactions_run{$b->[0]}{$a->[0]}) {
            @results = @{$term_interactions_run{$b->[0]}{$a->[0]}}
        }
        else {
            if ($n_terms == 1) {
                @results = return_results($mech,$a);
            } else {
                @results = return_results($mech,$a,$b);
            }
        }
        if (defined $pmid_output) {
            print {$pmid_output} "$a->[0] and $b->[0]\n";
            print {$pmid_output} "# ".
                join(' AND ',
                     map {
                         ref $_?('('.join(' OR ',
                                          map {qq("$_"[All Fields])} @{$_}
                                         ).')'):qq("$_"[All Fields])
                                     } ($a,$n_terms > 1 ?$b:())
                    )."\n";
            print {$pmid_output} "------\n";
            print {$pmid_output} map {"$_\n"} @results;
            print {$pmid_output} "------\n";
        }
        $term_interactions_run{$a->[0]}{$b->[0]} = \@results;
        $term_interactions_run{$b->[0]}{$a->[0]} = \@results;
        print scalar @results;
    }
    print "\n";# unless $options{output_pmids}
}

sub return_results {
    my ($l_mech,@l_terms) = @_;
    ## GET 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?term=TNF&retmax=500000
    my $terms = uri_escape(join(' AND ',
				map {
				    ref $_?('('.join(' OR ',
						     map{qq("$_"[All Fields])} @{$_}
						    ).')'):qq("$_"[All Fields])
						} @l_terms
			       )
			  );
    my $content = '';
    my $counter = 0;
 LOOP: {do {
	if ($l_mech->get('http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?retmax=500000&term='.
			 $terms
			)) {
	    $content = $l_mech->content;
	    last;
	}
	$counter++;
	sleep 10;
    } while ($counter < 100);
    }
    my (@ids) = $content =~ m{<Id>\s*(\d+)\s*</Id>}gi;
    return wantarray ? @ids : scalar @ids;
}

sub product {
    my $a=0; my $b=0;
    return reduce {$a * $b} @_;
}

__END__
